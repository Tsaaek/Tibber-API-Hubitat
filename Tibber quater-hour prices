/*
Tibber quater-hour prices

The driver fetches price info from Tibber API once an hour (refresh command), calculates day average price, low/high price and stores the data.
Every quater it updates the current price from the stored data and sets the child devices according to the current price.

Low/high prices.
The spread between the highest and lowest price of the day is calculated and is then multiplied with the factor set in the settings. The result is added to the lowest price and is used as a threshold for low prices. (For high prices it is subtracted from the highest price.)
Example:
Factor is set to 10%
Highest price is 120
Lowest price is 20
The spread is 120-20 = 100 * 10% = 10

Low price threshold = 20 + 10 = 30. Every hour with a price equal to or lower to 30 will be concidered as low price-hour. Stored in attribute lowPrice.
High price threshold = 120 - 10 = 110. Every hour with a price equal to or higher than 110 will be concidered as high price-hour. Stored in attribute highPrice.

The device has four child devices:
- Tibber_lowPrice - turns on when price is equal to or lower than lowPrice.
- Tibber_highPrice - turns on when price is equal to or higher than highPrice.
- Tibber_belowAvg - turns on when price is lower than or equal to day average price. (todayAvg)
- Tibber_aboveAvg - turns on when price is higher than day average price.

 */
import java.text.SimpleDateFormat
import groovy.json.JsonOutput
import groovy.json.JsonBuilder
import groovy.time.TimeCategory


metadata {
    definition(name: "Tibber quater-hour prices", namespace: "tsaaek", author: "Tommy Saaek", importUrl: "") {
	capability "Sensor"
	capability "Initialize"
	capability "Refresh"
	capability "Actuator"
	
	attribute "today", "String"
	attribute "avgToday", "Number"
	attribute "currentPrice", "NUMBER"
    	attribute "lowPrice", "Number"
	attribute "highPrice", "Number"
	attribute "fixedLowPrice", "Number"
	attribute "fixedHighPrice", "Number"
	attribute "priceFactor", "Number"
	attribute "numberOfLowPricePeriods", "Number"
	attribute "numberOfHighPricePeriods", "Number"
	    
	command "setFixedLowPrice", ["Number"]
	command "setFixedHighPrice", ["Number"]
	command "setPriceFactor", ["Number"]
	

	   
    }
}

preferences {
    section("Security") {
        input "securityToken", "text", title: "Tibber API-token", required: true

	input name: "logEnable", type: "bool", title: "Enable info logging", defaultValue: true
	
	    
    }

}


def logsOff() {
    log.warn "debug logging disabled..."
    device.updateSetting("logEnable", [value: "false", type: "bool"])
}

def updated() {
	initialize()
}

def logInfo(msg){
	if (logEnable) log.info msg	
}


def poll () {
	def rawString =  device.currentValue('today')
	def map = [:]


	rawString
    	.replaceAll(/[{}]/, '')
    	.split(', ') 
    	.each {
        def (key, value) = it.split('=') 
        map[key] = value.toInteger()      
    	}
	def time = addZero(new Date().getHours()) + ":" + addZero(new Date().getMinutes())				
	def currentPrice = map.getAt(time)

	logInfo("Polling")		
	if(currentPrice)sendEvent(name: "currentPrice", value: currentPrice)
	runIn(3,updateChildDevices)

}
def installed() {
    log.info "installed() called"
	sendEvent(name: "numberOfLowPricePeriods", value: 50)
	sendEvent(name: "numberOfHighPricePeriods", value: 350)
	sendEvent(name: "priceFactor", value: 10)
    	runIn(2,updated)
}

def initialize() {
	try {
		log.info "Creating child devices"
	addChildDevice("hubitat", "Virtual Switch", "${device.id}-lowPrice", [name : "Tibber_lowPrice"])
	addChildDevice("hubitat", "Virtual Switch", "${device.id}-highPrice", [name : "Tibber_highPrice"])
	addChildDevice("hubitat", "Virtual Switch", "${device.id}-belowAvg", [name : "Tibber_belowAvg"])
	addChildDevice("hubitat", "Virtual Switch", "${device.id}-aboveAvg", [name : "Tibber_aboveAvg"])
	    
	}
	            catch (Exception ex) {
                  // Child devices are already created
            }
	

	
	startSchedule()
	
}

def startSchedule(){
	log.info "Starting schedule"
	unschedule()
	schedule("00 00 * ? * *",poll, [overwrite: false])
	schedule("00 15 * ? * *",poll, [overwrite: false]) 
	schedule("00 30 * ? * *",poll, [overwrite: false])
	schedule("00 45 * ? * *",poll, [overwrite: false]) 
	schedule("00 57 23 ? * *",refresh, [overwrite: false])


}


def parseData(responseBody, data){
	try{
	def slurper = new groovy.json.JsonSlurper()
	def result = slurper.parseText(responseBody.data)
	def factor = device.currentValue("priceFactor")
	def todayOut = [:]
	def tomorrowOut = [:]
	def today = []
	def tomorrow = []
	def avgToday = 0
	def avgTomorrow = 0
	def spread = 0
	def tomorrowSpread = 0
	def total = 0
	def tomorrowTotal = 0
	def currentTime = new Date()

	if(currentTime.after(testTime(23,55,0))){ //Setting tomorrows prices as current day prices"
		result.data.viewer.homes[0].currentSubscription.priceInfo.tomorrow.each { post->
		todayOut.put(post.startsAt.substring(11, 16), Math.round(post.energy * 100))
		today.add(post.energy)
		total+= post.energy
	}
	}

	else{
	result.data.viewer.homes[0].currentSubscription.priceInfo.today.each { post->
		todayOut.put(post.startsAt.substring(11, 16), Math.round(post.energy * 100))
		today.add(post.energy)
		total+= post.energy
	}
	}
	
	state.today = today

	
	avgToday = Math.round((total / today.size()) * 100)
	state.retries = 0
	sendEvent(name: "avgToday", value: avgToday)
	sendEvent(name: "today", value: todayOut)
	sendEvent(name: "currentPrice", value: Math.round(result.data.viewer.homes[0].currentSubscription.priceInfo.current.energy * 100))
	runIn(2,calculate)
	}
	catch(e){
	log.error e
	if(state.retries == 5){
	log.error "API call failed. Hit 'refresh' to try again"
	} else {
	log.error "API call failed. Trying again in 10 seconds"
	runIn(10, callAPI)	
	}
	
	}
}

def updateChildDevices(){
	def childs = getChildDevices()
	def currentPrice = device.currentValue("currentPrice")
	
	if(currentPrice <= device.currentValue("lowPrice")  || currentPrice <= device.currentValue("fixedLowPrice")){
		childs[0].on()
		childs[1].off()
		logInfo("Current price is low")
		} 
	else if(currentPrice > device.currentValue("highPrice") || currentPrice <= device.currentValue("fixedHighPrice")){
		childs[0].off()
		childs[1].on()
		logInfo("Current price is high")
		}
	if(currentPrice <= device.currentValue("avgToday")){
		childs[2].on()
		childs[3].off()
		logInfo("Current price is below average price")
	} else {
		childs[2].off()
		childs[3].on()
		logInfo("Current price is above average price")
	}
}

def refresh(){
	state.retries = 0
	callAPI()
}

def callAPI(){
	state.retries = state.retries + 1
	if(state.retries <= 5){
		if(state.retries > 1){
			log.info "Fetching price data from Tibber API. Retry number " + state.retries + " of 5."
		} else {
		logInfo("Fetching price data from Tibber API")
		}
	    def postParams = [
            uri: "https://api.tibber.com/v1-beta/gql",
	    contentType: "application/json",
	    requestContentType: "application/json",
            headers: [ "Authorization": "Bearer $securityToken"],
            body: graphQLApiQuery()
        ]
        

        asynchttpPost('parseData', postParams)
		}
	
}

def calculate(){
	def factor = device.currentValue("priceFactor")
	
	def today = state.today
	today = today.sort()
	
	def todayMin = today.get(0)
	def todayMax = today.get(today.size() - 1)
	spread = (todayMax - todayMin) * (factor / 100)
	def lowPrice = Math.round((todayMin + spread) * 100)
	def highPrice = Math.round((todayMax - spread) * 100)
	
	
	def lowPriceNum = 0
	def highPriceNum = 0
	today.each {
		if((it * 100) <= lowPrice || (it * 100) <= device.currentValue("fixedLowPrice")) lowPriceNum++
		if((it * 100) > highPrice || (it * 100) > device.currentValue("fixedHighPrice")) highPriceNum++
	}
	sendEvent(name: "numberOfLowPricePeriods", value: lowPriceNum)
	sendEvent(name: "numberOfHighPricePeriods", value: highPriceNum)
	sendEvent(name: "lowPrice", value: lowPrice)
	sendEvent(name: "highPrice", value: highPrice)
	runIn(3, updateChildDevices)	
}

def graphQLApiQuery(){ 
    return '{"query": "{viewer {homes {currentSubscription{priceInfo(resolution: QUARTER_HOURLY) { current {energy} today{energy startsAt} tomorrow{energy startsAt}}}}}}", "variables": null, "operationName": null}';
}

def testTime(h,m,s){
	def time = new Date()
	time.setHours(h)
	time.setMinutes(m)
	time.setSeconds(s)
return time	
}



def addZero(x){	
	def out = ""
	if(x < 10){
		out += "0"+x
	}
	else{
		out += h
	}
return out
}

def setFixedLowPrice(x){
	sendEvent(name: "fixedLowPrice", value: x)
	runIn(1,calculate)
}

def setFixedHighPrice(x){
	sendEvent(name: "fixedHighPrice", value: x)	
	runIn(1,calculate)
}


def setPriceFactor(x){
	sendEvent(name: "priceFactor", value: x)	
	runIn(1,calculate)
}

